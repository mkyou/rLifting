---
title: "Custom Wavelets and Diagnostics"
output: 
  rmarkdown::html_vignette:
    css: style.css
    toc: true
    toc_depth: 2
vignette: >
  %\VignetteIndexEntry{Custom Wavelets and Diagnostics}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 7,
  fig.height = 4.5,
  warning = FALSE,
  message = FALSE
)
```

One of the greatest advantages of the *Lifting Scheme* over traditional wavelet convolution is flexibility.
`rLifting` allows for the implementation of new wavelets with just a few lines of code, provided the coefficients for the *predict* (P) and *update* (U) steps are known.

In this guide, we will cover:

-   How to implement new wavelets in `rLifting` using known Lifting coefficients.

-   How to validate the implementation using the Diagnostics suite.

```{r}
library(rLifting)
```

## Introduction

A wavelet can be constructed via the Lifting Scheme through a sequence of simple steps:

1.  **Split (Lazy Wavelet):** Separate the signal into even $(e)$ and odd $(o)$ samples.

2.  **Predict:** Attempt to predict odd samples $(o)$ using even samples $(e)$.
    The prediction error becomes the detail $(d)$: $d=o−P(e)$.

3.  **Update:** Update the even samples using the calculated details to maintain global properties (like average): $s=e+U(d)$.

The operators $P(\cdot)$ and $U(\cdot)$ are defined in `rLifting` using the `lift_step` function.

To illustrate, let's recreate the **Haar Wavelet**.
The Haar lifting coefficients for predict and update are $1$ and $0.5$, respectively.
Thus, $P(e)=1e=e$, and $U(d)=0.5d$.
A normalization vector K is also typically required.
For Haar, $K=(\sqrt{2},\sqrt{1/2})$.

```{r}
# 1. Prediction Step
# "center" automatically aligns the filter
p1 = lift_step(type = "predict", coeffs = c(1), position = "center")

# 2. Update Step
u1 = lift_step(type = "update", coeffs = c(0.5), position = "center")

# 3. Packaging
# Standard Haar Normalization: (sqrt(2), 1/sqrt(2))
my_haar = lifting_scheme(
  wavelet = "ManualHaar",
  custom_steps = list(p1, u1),
  custom_norm = c(sqrt(2), 1/sqrt(2))
)

print(my_haar)
```

### Diagnostics

Wavelets possess specific mathematical and physical properties.
To verify if our manually constructed wavelet behaves as expected, we use the `diagnose_wavelet` function.
For Haar, we expect **Perfect Reconstruction** (invertibility) and exactly **One Vanishing Moment** (degree 0, meaning it cancels out constant signals).

The function also generates a plot estimating the shape of the Scaling Function $(\phi)$ and the Wavelet Function $(\Psi)$ using the Cascade Algorithm.

```{r}
diagnose_wavelet(
  my_haar, list(
    is_ortho = TRUE, # Haar is orthogonal
    vm_degrees = c(0), # Tests only degree 0 (Constant)
    max_taps = 2 # Expected filter width
    )
  )
```

The Lifting Scheme inherently guarantees perfect reconstruction.
Thus, this test in `diagnose_wavelet` serves primarily as a sanity check for the code.
However, the process does *not* guarantee other properties like orthogonality or vanishing moments.
It is possible to construct "broken" wavelets that are invertible but useless for analysis.

Let's exemplify this by mixing a sophisticated Predict step from the CDF 9/7 wavelet with a simple Update step from Haar.
We expect the transform to be invertible, but to fail the vanishing moments tests.

```{r}
# Predict from CDF 9/7 (Sophisticated)
alpha = -1.586134342
p_hybrid = lift_step("predict", c(-alpha, -alpha), position = "center")

# Update from Haar (Too simple to compensate the Predict above)
u_hybrid = lift_step("update", c(0.5), position = "center")

frankenstein = lifting_scheme(
  wavelet = "FrankenWavelet",
  custom_steps = list(p_hybrid, u_hybrid)
)

# Running Diagnosis
diagnose_wavelet(
  frankenstein, 
  list(
    is_ortho = FALSE,
    vm_degrees = c(0, 1), # Testing degrees 0 and 1
    max_taps = 5
    )
  )
```

## Implementing DB4 (Daubechies 8-taps)

The `haar` wavelet is built-in.
In practice, you will use `lift_step` to implement wavelets not natively available.

Let's implement **DB4**.
It is more complex, requiring careful handling of indices (`start_idx`) and coefficient signs.
We will use coefficients from the MATLAB `liftingScheme` documentation.
DB4 has five steps (P,U,P,U,P).

**Important Note on Signs:** `rLifting` follows the **semantic definition** proposed by Sweldens, where detail is a residual error: d=o−P(e).
MATLAB follows an algebraic definition: d=o+α(e).
Therefore, to port MATLAB coefficients to `rLifting`, **we must invert the signs of the Predict coefficients**.

**Convention for `start_idx`:**

-   z1 (Future) → `start_idx = 1`

-   z−1 (Past) → `start_idx = -1`

```{r}
# Coefficients (Signs adjusted for rLifting engine: d = o - P(e))

# Step 1 (Predict): Term z^1
p1 = lift_step("predict", c(0.32227589), start_idx = 1)

# Step 2 (Update): Terms z^0, z^-1
u1 = lift_step("update", c(-0.30014226, -1.11712361), start_idx = -1)

# Step 3 (Predict): Terms z^2, z^1
p2 = lift_step("predict", c(-0.11764809, 0.01880835), start_idx = 1)

# Step 4 (Update): Terms z^0, z^-1
u2 = lift_step("update", c(0.63642827, 2.13181671), start_idx = -1)

# Step 5 (Predict): Terms z^0, z^-1, z^-2
p3 = lift_step(
  "predict", c(0.02479124, -0.14003924, 0.46908348), start_idx = -2
  )

# Normalization (K and 1/K)
norm_db4 = c(0.73412453, 1.36216672)

db4_custom = lifting_scheme(
  wavelet = "DB4_Custom",
  custom_steps = list(p1, u1, p2, u2, p3),
  custom_norm = norm_db4
)
```

If implemented correctly, `DB4_Custom` should pass vanishing moment tests up to degree 3 (cubic).

```{r}
diagnose_wavelet(
  db4_custom, list(
    is_ortho = TRUE,
    vm_degrees = c(0, 1, 2, 3),
    max_taps = 8
    )
  )
```

**Observation on Wavelet Shape and Numerical Precision:** While the diagnostic confirms that the wavelet satisfies the mathematical requirements (Perfect Reconstruction, 4 Vanishing Moments, and Orthogonality), you might notice in the generated plots that the shape, although fractal, appears jagged or slightly different from the standard textbook "Daubechies 4".

Regarding **Orthogonality**, a ratio of `1.000000` (or extremely close to it) indicates that energy is conserved.
Theoretical orthogonality implies an exact ratio of 1, but due to floating-point arithmetic, negligible numerical errors are expected.

The shape differences occur because Lifting factorizations are not unique.
The specific sequence of steps used here (derived from one specific factorization) is mathematically valid but yields a slightly different phase or regularity appearance than the classical convolution-based construction.
**This highlights the importance of the `diagnose_wavelet` tool:** it confirms the physics (moments/energy) even if the visual shape varies slightly due to factorization choices.

## Conclusion

`rLifting` enables the implementation of any wavelet that can be factored into lifting steps.
This is useful for testing coefficients from new research papers, porting wavelets from other software, and physically validating the properties of the transform via the diagnostics suite.
