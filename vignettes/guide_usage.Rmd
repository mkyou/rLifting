---
title: "General Usage Guide: rLifting"
output: 
  rmarkdown::html_vignette:
    css: style.css
    toc: true
    toc_depth: 2
vignette: >
  %\VignetteIndexEntry{General Usage Guide}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  markdown: 
    wrap: sentence
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 7,
  fig.height = 4.5,
  warning = FALSE,
  message = FALSE
)
```

This guide introduces the core functionalities of the `rLifting` package.
It is designed to bridge the gap between traditional signal analysis and modern real-time requirements.

We will focus on **Signal Denoising**, comparing two fundamental approaches available in the package:

1.  **Offline Denoising (Non-Causal / Batch):** In this mode, the algorithm has access to the entire signal (past and future) at once.
    By "seeing the future", it can calculate global statistics and smooth the signal more effectively without lag.
    This is ideal for historical data analysis.

2.  **Online Denoising (Causal / Adaptive):** In this mode, data points arrive sequentially (e.g., from a sensor).
    The algorithm cannot "see" the future and must rely on a sliding window of past data.
    This introduces challenges like phase lag but enables real-time decision-making.

## Setup

Ensure `rLifting` is installed and loaded.
We will also use `ggplot2` and `tidyr` for visualization.

```{r}
library(rLifting)
library(ggplot2)
library(tidyr)
```

## Practical Example: Haar and the Doppler Signal

We begin with the Haar wavelet.
Although simple, it is excellent for illustrating the mechanics of the algorithm.
We will treat a Doppler function with $T=2048$ points contaminated by noise.

```{r}
# Generate synthetic test data
set.seed(2025)
n_samples = 2048
signal_pure = rLifting:::.generate_signal("doppler", n = n_samples)

# Add Gaussian noise
noise = rnorm(n_samples, sd = 0.5)
signal_noisy = signal_pure + noise

# Prepare DataFrame for ggplot
df_signal = data.frame(
  Index = 1:n_samples,
  Original = signal_pure,
  Noisy = signal_noisy
)

# Visualization
ggplot(df_signal, aes(x = Index)) +
  geom_line(aes(y = Noisy, color = "Noisy"), alpha = 0.6, size = 0.3) +
  geom_line(aes(y = Original, color = "Original"), size = 0.8) +
  scale_color_manual(values = c("Original" = "black", "Noisy" = "grey30")) +
  labs(
    title = "Doppler Function with Noise", 
    y = "Amplitude", 
    color = "Legend"
    ) +
  theme_bw() +
  theme(legend.position = "top")
```

### Offline Denoising (Non-Causal / Global)

The function `denoise_signal_offline` processes the entire vector in a single batch.
It calculates the noise threshold based on the **global median absolute deviation (MAD)** of the detail coefficients across the whole signal.

**A Note on Boundary Extension:** Wavelets need to handle signal boundaries.
The package default is `extension = "symmetric"` (reflection), which reduces artifacts at the edges.
Other options are `"periodic"` (circular) and `"zero"` (padding).
While Haar is robust, symmetric extension is generally recommended for smoother wavelets to avoiding discontinuities.

```{r}
# Define Lifting Scheme
scheme_haar = lifting_scheme("haar")

# Apply Filter
signal_haar = denoise_signal_offline(
  signal_noisy, 
  scheme = scheme_haar,
  method = "soft", # Thresholding method. Options: "hard", "soft", "semisoft"
  levels = 3,
  extension = "symmetric"
)

df_signal$Offline = signal_haar

ggplot(subset(df_signal, Index >= 500 & Index <= 1000), aes(x = Index)) +
  geom_line(aes(y = Noisy, color = "Noisy"), alpha = 0.5) +
  geom_line(aes(y = Original, color = "Original"), linetype = "dashed") +
  geom_line(aes(y = Offline, color = "Filtered (Haar)"), size = 1) +
  scale_color_manual(
    values = c(
      "Original" = "black", 
      "Noisy" = "grey30", 
      "Filtered (Haar)" = "royalblue")
    ) +
  labs(
    title = "Offline Denoising (Zoom)", 
    subtitle = "Note the characteristic 'steps' of the Haar wavelet", 
    y = "Amplitude"
    ) +
  theme_bw() +
  theme(legend.position = "top")
```

### Causal Denoising (Real-Time / Adaptive)

In monitoring applications (IoT sensors, high-frequency trading), we do not have access to the "future" of the signal.
The causal smoother uses a **Sliding Window** and a **Recursive Adaptive Threshold** (based on Liu et al., 2014).

This method (as implemented in `rLifting`) introduces two physical phenomena:

1.  **Warm-up:** The first samples (equal to the window size) are not filtered (returned as raw), because the algorithm needs to accumulate enough history to statistically estimate the noise level.

2.  **Phase Lag:** The filter takes slightly longer to react to abrupt changes because it relies solely on past data to estimate the current state.

```{r}
# Window size W
window_w = 256

# Causal Processing
# Note: We set levels=3 to match the offline depth.
signal_causal = denoise_signal_causal(
  signal_noisy,
  scheme = scheme_haar,
  levels = 3,
  window_size = window_w,
  method = "semisoft",
  alpha = 0.3,
  beta = 1.2
)

df_signal$Causal = signal_causal

# Comparative Visualization (Focusing on Lag and Smoothing)
# Zooming in on a fast transition area
ggplot(
  subset(df_signal, Index >= 200 & Index <= 800), 
  aes(x = Index)
  ) +
  # Noise layer (background)
  geom_line(aes(y = Noisy), color = "grey30", alpha = 0.8) +
  # Reference
  geom_line(
    aes(y = Original, color = "Original"), 
    linetype = "dashed", alpha = 0.7
    ) +
  # Comparison
  geom_line(aes(y = Offline, color = "Offline (Global)"), size = 0.8) +
  geom_line(aes(y = Causal, color = "Causal (Real-Time)"), size = 0.8) +
  # Warm-up Marker
  geom_vline(xintercept = window_w, linetype = "dotted", color = "black") +
  annotate(
    "text", 
    x = window_w + 5, 
    y = max(signal_pure) + 1, 
    label = "Warm-up End",
    hjust = 0, 
    color = "black", 
    size = 3
    ) +
  
  scale_color_manual(
    values = c(
      "Original" = "black",
      "Offline (Global)" = "royalblue",
      "Causal (Real-Time)" = "firebrick"
      )
    ) +
  labs(
    title = "Comparison: Offline vs. Causal",
    subtitle = "Causal removes noise but exhibits natural phase lag compared to Offline",
    y = "Amplitude"
    ) +
  theme_bw() +
  theme(legend.position = "bottom")
```

It is evident that both methods significantly improve the signal-to-noise ratio.
The **Offline** method, being able to "look ahead," is inherently superior in reconstruction accuracy.
However, the **Causal** method proves to be a robust alternative for scenarios where looking ahead is impossible.

## Additional Information and References

### Thresholding Methods

The choice of the shrinkage function defines how wavelet coefficients are attenuated.
`rLifting` provides three approaches:

-   `hard`: Keeps the original amplitude of surviving coefficients but its discontinuity generates higher variance (residual artifacts).

-   `soft`: Shrinks everything towards zero.
    Result is very smooth but introduces amplitude bias (shrinks the signal along with the noise).

-   `semisoft`: (Default) A hyperbolic balance.
    Behaves like `hard` for large amplitudes (preserving peaks) and `soft` for small amplitudes (stability).

### Available Wavelets

Beyond `haar`, the package natively includes:

-   `db2`: Daubechies 4-taps (Asymmetric).

-   `cdf53` (or bior2.2): LeGall 5/3 (Linear, fast, integer-ready).

-   `cdf97` (or bior4.4): Cohen-Daubechies-Feauveau 9/7 (Smooth, used in JPEG2000).

-   `dd4`: Deslauriers-Dubuc (Cubic interpolating).

### Next Steps

`rLifting` is extensible.
Check the other vignettes for deeper dives:

1.  **Custom Wavelets:** Learn how to implement complex wavelets (like DB4) manually using the `lift_steps` API.

2.  **Statistical Benchmarks:** Comprehensive comparisons between thresholding methods and causal/non-causal approaches using Monte Carlo simulations.

3.  **Computational Performance:** Stress testing the C++ engine for high-frequency throughput.
